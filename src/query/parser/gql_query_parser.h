#pragma once

#include "misc/logger.h"
#include "query/parser/grammar/error_listener.h"
#include "query/parser/grammar/gql/autogenerated/GQLLexer.h"
#include "query/parser/grammar/gql/autogenerated/GQLParser.h"
#include "query/parser/grammar/gql/query_visitor.h"
#include "query/parser/op/gql/op.h"
#include "query/rewriter/gql/op/add_linear_patterns.h"
#include "query/rewriter/gql/op/add_starting_enum.h"
#include "query/rewriter/gql/op/check_statements.h"
#include "query/rewriter/gql/op/check_unbounded_repetition.h"
#include "query/rewriter/gql/op/check_var_existence.h"
#include "query/rewriter/gql/op/extract_exprs.h"
#include "query/rewriter/gql/op/extract_optional_labels.h"
#include "query/rewriter/gql/op/extract_optional_properties.h"
#include "query/rewriter/gql/op/push_labels.h"
#include "query/rewriter/gql/op/push_properties.h"
#include "query/rewriter/gql/op/rewrite_rule_visitor.h"
#include "query/rewriter/gql/op/rewrite_rules/expr_into_normal_form.h"
#include "query/rewriter/gql/op/rewrite_rules/flatten_graph_patterns.h"
#include "query/rewriter/gql/op/rewrite_rules/remove_empty_filter.h"

namespace GQL {

class QueryParser {
public:
    static std::unique_ptr<Op> get_query_plan(const std::string& query)
    {
        antlr4::ANTLRInputStream input(query);
        GQLLexer lexer(&input);
        antlr4::CommonTokenStream tokens(&lexer);
        GQLParser parser(&tokens);

        parser.getInterpreter<antlr4::atn::ParserATNSimulator>()->setPredictionMode(
            antlr4::atn::PredictionMode::SLL
        );

        antlr4::MyErrorListener error_listener;
        parser.removeErrorListeners();
        parser.addErrorListener(&error_listener);

        GQLParser::RootContext* tree = parser.root();
        QueryVisitor visitor;
        visitor.visitRoot(tree);

        auto res = std::move(visitor.current_op);

        // logger(Category::LogicalPlan, 1) << "Initial logical plan:\n" << *res;

        res->print_to_ostream(std::cout);

        res->get_var_types();

        std::cout << std::endl;

        res = rewrite(std::move(res));

        std::cout << "\nAFTER REWRITING" << std::endl;
        res->print_to_ostream(std::cout);
        std::cout.flush();

        return res;
    }

    static std::unique_ptr<Op> rewrite(std::unique_ptr<Op> op)
    {
        CheckVarExistence var_visitor;
        op->accept_visitor(var_visitor);

        CheckUnboundedRepetition repetition_visitor;
        op->accept_visitor(repetition_visitor);

        CheckStatements statements_visitor;
        op->accept_visitor(statements_visitor);

        AddLinearPatterns add_linear_patterns;
        op->accept_visitor(add_linear_patterns);
        op = std::move(add_linear_patterns.tmp);

        AddStartingEnum starting_enum;
        op->accept_visitor(starting_enum);

        PushProperties properties_visitor;
        op->accept_visitor(properties_visitor);
        op = std::move(properties_visitor.tmp);

        PushLabels push_labels;
        op->accept_visitor(push_labels);
        op = std::move(push_labels.tmp);

        ExtractExprs exprs_visitor;
        op->accept_visitor(exprs_visitor);
        op = std::move(exprs_visitor.tmp);

        RewriteRuleVisitor rule_rewriter;
        rule_rewriter.add_rule<ExprIntoNormalForm>();
        rule_rewriter.add_rule<RemoveEmptyFilter>();
        rule_rewriter.begin_visit(op);

        return op;
    }
};
} // namespace GQL
