#pragma once

#include "antlr4-runtime.h"

#include "misc/logger.h"
#include "query/parser/grammar/error_listener.h"
#include "query/parser/grammar/sparql/query_autogenerated/SparqlQueryLexer.h"
#include "query/parser/grammar/sparql/query_autogenerated/SparqlQueryParser.h"
#include "query/parser/grammar/sparql/query_visitor.h"
#include "query/parser/op/op.h"
#include "query/query_context.h"
#include "query/rewriter/sparql/op/change_join_to_sequence.h"
#include "query/rewriter/sparql/op/check_scoped_blank_nodes.h"
#include "query/rewriter/sparql/op/check_var_names.h"
#include "query/rewriter/sparql/op/check_well_designed.h"
#include "query/rewriter/sparql/op/replace_unscoped_variables.h"
#include "query/rewriter/sparql/op/rewrite_filter_subqueries.h"
#include "query/rewriter/sparql/op/rewrite_rule_visitor.h"
#include "query/rewriter/sparql/op/rewrite_rules/decompress_and_filter.h"
#include "query/rewriter/sparql/op/rewrite_rules/distribute_filter_over_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/distribute_join_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/distribute_minus_to_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/distribute_optionals_to_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/exists_to_semi_join.h"
#include "query/rewriter/sparql/op/rewrite_rules/expr_into_normal_form.h"
#include "query/rewriter/sparql/op/rewrite_rules/flatten_filter.h"
#include "query/rewriter/sparql/op/rewrite_rules/flatten_union.h"
#include "query/rewriter/sparql/op/rewrite_rules/literal_removal.h"
#include "query/rewriter/sparql/op/rewrite_rules/not_exists_to_minus.h"
#include "query/rewriter/sparql/op/rewrite_rules/push_filter_into.h"
#include "query/rewriter/sparql/op/rewrite_rules/push_join_into_optional.h"
#include "query/rewriter/sparql/op/rewrite_rules/remove_empty_filter.h"
#include "query/rewriter/sparql/op/rewrite_rules/simplify_bound.h"
#include "query/rewriter/sparql/op/translate_property_paths.h"

namespace SPARQL {

class QueryParser {
public:
    static std::unique_ptr<Op> get_query_plan(const std::string& query)
    {
        antlr4::ANTLRInputStream  input(query);
        SparqlQueryLexer          lexer(&input);
        antlr4::CommonTokenStream tokens(&lexer);
        SparqlParser              parser(&tokens);

        parser.getInterpreter<antlr4::atn::ParserATNSimulator>()->setPredictionMode(
            antlr4::atn::PredictionMode::SLL
        );

        antlr4::MyErrorListener error_listener;
        parser.removeErrorListeners();
        parser.addErrorListener(&error_listener);

        SparqlParser::QueryContext* tree = parser.query();

        QueryVisitor::GlobalInfo global_info;
        QueryVisitor visitor(global_info);
        visitor.visitQuery(tree);

        auto res = rewrite(std::move(visitor.current_op));

        logger(Category::LogicalPlan) << *res;

        return res;
    }

    static std::unique_ptr<Op> rewrite(std::unique_ptr<Op> op) {
        // logger(Category::LogicalPlan, 0) << "Initial logical plan:\n" << *op;

        TranslatePropertyPaths translate_property_paths;
        op->accept_visitor(translate_property_paths);
        // logger(Category::LogicalPlan, 0) << "Translating property paths:\n" << *op;

        CheckVarNames check_var_names;
        op->accept_visitor(check_var_names);

        CheckScopedBlankNodes check_scoped_blank_nodes;
        op->accept_visitor(check_scoped_blank_nodes);

        ReplaceUnscopedVariables replace_unscoped_variables;
        op->accept_visitor(replace_unscoped_variables);
        // logger(Category::LogicalPlan, 0) << "Replacing unscoped variables:\n" << *op;

        QueryParser::use_all_rewrite_rules(op);
        // logger(Category::LogicalPlan, 0) << "Applying all rewrite rules:\n" << *op;

        ChangeJoinToSequence join_to_sequence_visitor;
        op->accept_visitor(join_to_sequence_visitor);
        // logger(Category::LogicalPlan, 0) << "Changing join to sequence:\n" << *op;

        RewriteFilterSubqueries rewrite_filter_subqueries;
        op->accept_visitor(rewrite_filter_subqueries);
        // logger(Category::LogicalPlan, 0) << "Rewriting filter subqueries:\n" << *op;
        return op;
    }

    static void use_all_rewrite_rules(std::unique_ptr<Op>& op) {
        RewriteRuleVisitor rule_rewriter;

        CheckWellDesigned check_well_designed;
        op->accept_visitor(check_well_designed);
        if (check_well_designed.is_well_designed) {
            rule_rewriter.add_rule<PushJoinIntoOptional>();
        }

        rule_rewriter.add_rule<DistributeJoinUnion        >();
        rule_rewriter.add_rule<DistributeOptionalsToUnion >();
        rule_rewriter.add_rule<DistributeMinusToUnion     >();
        rule_rewriter.add_rule<FlattenUnion               >();
        rule_rewriter.add_rule<ExprIntoNormalForm         >();
        rule_rewriter.add_rule<DecompressAndFilter        >();
        rule_rewriter.add_rule<FlattenFilter              >();
        rule_rewriter.add_rule<LiteralRemoval             >();
        rule_rewriter.add_rule<SimplifyBound              >();
        rule_rewriter.add_rule<RemoveEmptyFilter          >();
        rule_rewriter.add_rule<PushFilterInto<OpJoin>     >();
        rule_rewriter.add_rule<PushFilterInto<OpOptional> >();
        rule_rewriter.add_rule<PushFilterInto<OpMinus>    >();
        rule_rewriter.add_rule<DistributeFilterOverUnion  >();
        rule_rewriter.add_rule<NotExistsToMinus           >();
        rule_rewriter.add_rule<ExistsToSemiJoin           >();

        rule_rewriter.begin_visit(op);
    }
};

} // namespace SPARQL
