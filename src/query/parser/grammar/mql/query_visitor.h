#pragma once

#include <memory>
#include <vector>
#include <regex>

#include <boost/unordered/unordered_flat_map.hpp>

#include "graph_models/object_id.h"
#include "query/parser/grammar/mql/autogenerated/MQL_ParserBaseVisitor.h"
#include "query/parser/op/mql/ops.h"
#include "query/parser/paths/regular_path_expr.h"

namespace MQL {
class Expr;

class OpBasicGraphPattern;

class QueryVisitor : public MQL_ParserBaseVisitor {
private:
    struct ReturnInfo {
        std::vector<std::pair<std::unique_ptr<Expr>, VarId>> items;
        bool distinct;
        uint64_t limit = Op::DEFAULT_LIMIT;
        uint64_t offset = Op::DEFAULT_OFFSET;
    };

    struct OrderByInfo {
        std::vector<std::unique_ptr<Expr>> items;

        // must have the same size as items
        std::vector<bool> ascending_order;
    };

    struct HNSWIndexOptions {
        std::string property;
        std::string metric;
        uint64_t dimension;
        uint64_t max_edges;
        uint64_t max_candidates;

        boost::unordered_flat_map<std::string, bool> opt2seen = {
            {     "property", false},
            {       "metric", false},
            {    "dimension", false},
            {     "maxEdges", false},
            {"maxCandidates", false}
        };

        std::vector<std::string> valid_options() const {
            std::vector<std::string> keys;
            keys.reserve(opt2seen.size());
            for (const auto& [key, _] : opt2seen) {
                keys.emplace_back(key);
            }
            return keys;
        }

        void validate() const
        {
            for (const auto& [key, is_set] : opt2seen) {
                if (!is_set) {
                    throw QueryException("Missing HNSW Index option: \"" + key + "\"");
                }
            }

            if (!QueryVisitor::is_valid_property_key(property)) {
                throw QueryException("Invalid property: \"" + property + "\"");
            }

            if (metric != "cosineDistance" && metric != "manhattanDistance"
                && metric != "euclideanDistance")
            {
                throw QueryException(
                    "Invalid metric: \"" + metric
                    + "\". Expected one of the following: { cosineDistance, manhattanDistance, "
                      "euclideanDistance }"
                );
            }

            if (dimension == 0) {
                throw QueryException("Invalid dimension: must be a positive integer");
            }

            if (max_edges == 0) {
                throw QueryException("Invalid maxEdges: must be a positive integer");
            }

            if (max_candidates == 0) {
                throw QueryException("Invalid maxCandidates: must be a positive integer");
            }
        }
    };

    struct TextIndexOptions {
        std::string property;
        std::string normalization { "nfkdCasefold"}; // optional
        std::string tokenization { "wsSplitPunc" }; // optional

        boost::unordered_flat_map<std::string, bool> opt2seen = {
            {     "property", false},
            {"normalization", false},
            { "tokenization", false}
        };

        void validate() const
        {
            for (const auto& [key, is_set] : opt2seen) {
                if (!is_set && (key != "normalization" && key != "tokenization")) {
                    throw QueryException("Missing HNSW Index option: \"" + key + "\"");
                }
            }

            if (!QueryVisitor::is_valid_property_key(property)) {
                throw QueryException("Invalid property: \"" + property + "\"");
            }

            if (normalization != "identity" && normalization != "nfkdCasefold") {
                throw QueryException(
                    "Invalid normalization: \"" + normalization
                    + "\". Expected one of the following: { identity, nfkdCasefold }"
                );
            }

            if (tokenization != "identity" && tokenization != "wsSplitPunc" && tokenization != "wsRmPunc"
                && tokenization != "wsKeepPunc")
            {
                throw QueryException(
                    "Invalid tokenization: \"" + tokenization
                    + "\". Expected one of the following: { identity, wsSplitPunc, wsRmPunc, wsKeepPunc }"
                );
            }
        }

        std::vector<std::string> valid_options() const
        {
            std::vector<std::string> keys;
            keys.reserve(opt2seen.size());
            for (const auto& [key, _] : opt2seen) {
                keys.emplace_back(key);
            }
            return keys;
        }
    };

    ReturnInfo return_info;

    OrderByInfo order_by_info;

    // Properties used declared inside MATCH
    std::set<OpProperty> match_var_properties;

    std::vector<std::unique_ptr<Expr>> group_by_exprs;

    std::unique_ptr<Expr> current_expr;

    std::vector<std::unique_ptr<Expr>> property_expr;

    ObjectId current_value_oid;

    std::vector<std::unique_ptr<Expr>> current_call_argument_exprs;
    std::map<std::string, VarId> current_call_yield_var2alias;

    // Properties info in queries with operators (==, !=, >, <, >=, <=)
    // (?x {value == 4})
    // var_without_propertyId, keyId
    std::vector<PropertyOperatorConstraint> properties_operators;

    std::unique_ptr<OpBasicGraphPattern> current_basic_graph_pattern;

    std::set<VarId> possible_disjoint_vars;

    std::unique_ptr<RegularPathExpr> current_path;

    std::vector<OpLabel> insert_labels;

    std::vector<OpProperty> insert_properties;

    std::vector<OpEdge> insert_edges;

    // to detect possible disjoint vars / terms
    // initialized false to avoid calling
    // current_basic_graph_pattern->add_disjoint_term (segfault)
    // when seeing a DESCRIBE query
    bool first_element_disjoint = false;

    bool current_path_inverse;

    Id last_node = ObjectId::get_null();

    Id saved_node = ObjectId::get_null();

    Id saved_edge = ObjectId::get_null();

    Id saved_type = ObjectId::get_null();

    Id saved_property_obj = ObjectId::get_null();

    std::vector<float> current_tensor;

    static inline bool is_valid_property_key(const std::string& key) {
        static const std::regex pattern(R"([A-Za-z][A-Za-z0-9_]*)");
        return std::regex_match(key, pattern);
    }

    // receives either a TextIndexOptions or a HNSWIndexOptions
    // Parses the CreateIndexOptionsContext and validate it with the given struct and OptionhandlerFunc
    template<typename IndexOptions, typename OptionHandlerFunc>
    void parse_index_options(MQL_Parser::CreateIndexOptionsContext* ctx, IndexOptions& index_opts, OptionHandlerFunc option_handler_func);

    // try to parse str as datatype and store it as current_value_oid
    // if datatype is not valid will throw an exception
    void parse_datatype_value(const std::string& datatype, const std::string& str);

public:
    std::unique_ptr<Op> current_op;

    virtual std::any visitDescribeQuery(MQL_Parser::DescribeQueryContext*) override;
    virtual std::any visitShowQuery(MQL_Parser::ShowQueryContext* ctx) override;
    // virtual std::any visitInsertQuery(MQL_Parser::InsertQueryContext* ctx) override;
    virtual std::any visitMatchQuery(MQL_Parser::MatchQueryContext* ctx) override;
    virtual std::any visitMatchStatement(MQL_Parser::MatchStatementContext* ctx) override;

    virtual std::any visitInsertPatterns(MQL_Parser::InsertPatternsContext* ctx) override;
    virtual std::any visitInsertLinearPattern(MQL_Parser::InsertLinearPatternContext* ctx) override;
    virtual std::any visitInsertPlainNode(MQL_Parser::InsertPlainNodeContext* ctx) override;
    virtual std::any visitInsertPlainEdge(MQL_Parser::InsertPlainEdgeContext* ctx) override;
    // virtual std::any visitInsertStatement(MQL_Parser::InsertStatementContext* ctx) override;
    // virtual std::any visitInsertLabelElement(MQL_Parser::InsertLabelElementContext* ctx) override;
    // virtual std::any visitInsertPropertyElement(MQL_Parser::InsertPropertyElementContext* ctx) override;
    // virtual std::any visitInsertEdgeElement(MQL_Parser::InsertEdgeElementContext* ctx) override;

    virtual std::any visitCallStatement(MQL_Parser::CallStatementContext* ctx) override;
    virtual std::any visitCallArguments(MQL_Parser::CallArgumentsContext* ctx) override;
    virtual std::any visitYieldStatement(MQL_Parser::YieldStatementContext* ctx) override;

    virtual std::any visitLetStatement(MQL_Parser::LetStatementContext* ctx) override;

    virtual std::any visitReturnList(MQL_Parser::ReturnListContext* ctx) override;
    virtual std::any visitReturnItemVar(MQL_Parser::ReturnItemVarContext* ctx) override;
    virtual std::any visitReturnItemExpr(MQL_Parser::ReturnItemExprContext* ctx) override;
    virtual std::any visitReturnItemAgg(MQL_Parser::ReturnItemAggContext* ctx) override;
    virtual std::any visitReturnItemCount(MQL_Parser::ReturnItemCountContext* ctx) override;
    virtual std::any visitReturnAll(MQL_Parser::ReturnAllContext* ctx) override;

    virtual std::any visitOrderByStatement(MQL_Parser::OrderByStatementContext* ctx) override;
    virtual std::any visitOrderByItemVar(MQL_Parser::OrderByItemVarContext* ctx) override;
    virtual std::any visitOrderByItemExpr(MQL_Parser::OrderByItemExprContext* ctx) override;
    virtual std::any visitOrderByItemAgg(MQL_Parser::OrderByItemAggContext* ctx) override;
    virtual std::any visitOrderByItemCount(MQL_Parser::OrderByItemCountContext* ctx) override;

    virtual std::any visitGroupByStatement(MQL_Parser::GroupByStatementContext* ctx) override;
    virtual std::any visitGroupByItem(MQL_Parser::GroupByItemContext* ctx) override;

    virtual std::any visitGraphPattern(MQL_Parser::GraphPatternContext* ctx) override;
    virtual std::any visitBasicPattern(MQL_Parser::BasicPatternContext* ctx) override;
    virtual std::any visitLinearPattern(MQL_Parser::LinearPatternContext* ctx) override;
    virtual std::any visitFixedNodeInside(MQL_Parser::FixedNodeInsideContext* ctx) override;
    virtual std::any visitVarNode(MQL_Parser::VarNodeContext* ctx) override;
    virtual std::any visitEdge(MQL_Parser::EdgeContext* ctx) override;
    virtual std::any visitEdgeInside(MQL_Parser::EdgeInsideContext* ctx) override;
    virtual std::any visitProperty1(MQL_Parser::Property1Context* ctx) override;
    virtual std::any visitProperty2(MQL_Parser::Property2Context* ctx) override;
    virtual std::any visitProperty3(MQL_Parser::Property3Context* ctx) override;
    virtual std::any visitProperty4(MQL_Parser::Property4Context* ctx) override;

    virtual std::any visitPath(MQL_Parser::PathContext* ctx) override;
    virtual std::any visitPathAlternatives(MQL_Parser::PathAlternativesContext* ctx) override;
    virtual std::any visitPathSequence(MQL_Parser::PathSequenceContext* ctx) override;
    virtual std::any visitPathAtomSimple(MQL_Parser::PathAtomSimpleContext* ctx) override;
    virtual std::any visitPathAtomAlternatives(MQL_Parser::PathAtomAlternativesContext* ctx) override;


    virtual std::any visitExprVar(MQL_Parser::ExprVarContext* ctx) override;
    virtual std::any visitExprFixedNodeInside(MQL_Parser::ExprFixedNodeInsideContext* ctx) override;
    virtual std::any visitExprValue(MQL_Parser::ExprValueContext* ctx) override;

    virtual std::any visitConditionalOrExpr(MQL_Parser::ConditionalOrExprContext* ctx) override;
    virtual std::any visitConditionalAndExpr(MQL_Parser::ConditionalAndExprContext* ctx) override;
    virtual std::any visitComparisonExprOp(MQL_Parser::ComparisonExprOpContext* ctx) override;
    virtual std::any visitComparisonExprIs(MQL_Parser::ComparisonExprIsContext* ctx) override;
    virtual std::any visitAdditiveExpr(MQL_Parser::AdditiveExprContext* ctx) override;
    virtual std::any visitMultiplicativeExpr(MQL_Parser::MultiplicativeExprContext* ctx) override;
    virtual std::any visitUnaryExpr(MQL_Parser::UnaryExprContext* ctx) override;
    virtual std::any visitFunction(MQL_Parser::FunctionContext* ctx) override;

    virtual std::any visitRegex(MQL_Parser::RegexContext* ctx) override;
    virtual std::any visitCosineSimilarity(MQL_Parser::CosineSimilarityContext* ctx) override;
    virtual std::any visitCosineDistance(MQL_Parser::CosineDistanceContext* ctx) override;
    virtual std::any visitManhattanDistance(MQL_Parser::ManhattanDistanceContext* ctx) override;
    virtual std::any visitEuclideanDistance(MQL_Parser::EuclideanDistanceContext* ctx) override;

    virtual std::any visitCreateIndexQuery(MQL_Parser::CreateIndexQueryContext* ctx) override;

    virtual std::any visitValue(MQL_Parser::ValueContext* ctx) override;
};
} // namespace MQL
