#pragma once

#include <cstdint>
#include <memory>
#include <stack>
#include <vector>

#include "query/exceptions.h"
#include "query/id.h"
#include "query/parser/grammar/sparql/update_autogenerated/SparqlUpdateParserBaseVisitor.h"
#include "query/parser/op/sparql/op_triple.h"
#include "query/query_context.h"

#include "antlr4-runtime.h"

namespace SPARQL {

class UpdateVisitor : public SparqlUpdateParserBaseVisitor {
private:
    struct HNSWIndexOptions {
        std::string predicate;
        std::string metric;
        uint64_t dimension;
        uint64_t max_edges;
        uint64_t max_candidates;

        boost::unordered_flat_map<std::string, bool> opt2seen = {
            {      "predicate", false },
            {        "metric", false },
            {     "dimension", false },
            {      "maxEdges", false },
            { "maxCandidates", false }
        };

        std::vector<std::string> valid_options() const
        {
            std::vector<std::string> keys;
            keys.reserve(opt2seen.size());
            for (const auto& [key, _] : opt2seen) {
                keys.emplace_back(key);
            }
            return keys;
        }

        void validate() const
        {
            for (const auto& [key, is_set] : opt2seen) {
                if (!is_set) {
                    throw QueryException("Missing HNSW Index option: \"" + key + "\"");
                }
            }

            if (metric != "cosineDistance" && metric != "manhattanDistance" && metric != "euclideanDistance")
            {
                throw QueryException(
                    "Invalid metric: \"" + metric
                    + "\". Expected one of the following: { cosineDistance, manhattanDistance, "
                      "euclideanDistance }"
                );
            }

            if (dimension == 0) {
                throw QueryException("Invalid dimension: must be a positive integer");
            }

            if (max_edges == 0) {
                throw QueryException("Invalid maxEdges: must be a positive integer");
            }

            if (max_candidates == 0) {
                throw QueryException("Invalid maxCandidates: must be a positive integer");
            }
        }
    };

    struct TextIndexOptions {
        std::string predicate;
        std::string normalization { "nfkdCasefold" }; // optional
        std::string tokenization { "wsSplitPunc" }; // optional

        boost::unordered_flat_map<std::string, bool> opt2seen = {
            {      "predicate", false },
            { "normalization", false },
            {  "tokenization", false }
        };

        void validate() const
        {
            for (const auto& [key, is_set] : opt2seen) {
                if (!is_set && (key != "normalization" && key != "tokenization")) {
                    throw QueryException("Missing HNSW Index option: \"" + key + "\"");
                }
            }

            if (normalization != "identity" && normalization != "nfkdCasefold") {
                throw QueryException(
                    "Invalid normalization: \"" + normalization
                    + "\". Expected one of the following: { identity, nfkdCasefold }"
                );
            }

            if (tokenization != "identity" && tokenization != "wsSplitPunc" && tokenization != "wsRmPunc"
                && tokenization != "wsKeepPunc")
            {
                throw QueryException(
                    "Invalid tokenization: \"" + tokenization
                    + "\". Expected one of the following: { identity, wsSplitPunc, wsRmPunc, wsKeepPunc }"
                );
            }
        }

        std::vector<std::string> valid_options() const
        {
            std::vector<std::string> keys;
            keys.reserve(opt2seen.size());
            for (const auto& [key, _] : opt2seen) {
                keys.emplace_back(key);
            }
            return keys;
        }
    };

    // GlobalInfo& global_info;
    std::string base_iri;

    std::unordered_map<std::string, std::string> iri_prefix_map;

    std::unordered_map<std::string, ObjectId> bnode_map;

    std::vector<OpTriple> current_triples;

    Id current_sparql_element = ObjectId::get_null(); // initial value won't be used

    std::stack<Id> subject_stack;
    std::stack<Id> predicate_stack;
    std::stack<Id> object_stack;

    // uint64_t last_blank;

    // Parsing helpers
    std::string iriCtxToString(SparqlUpdateParser::IriContext*);

    std::string stringCtxToString(SparqlUpdateParser::StringContext*);

    ObjectId handleIntegerString(const std::string&, const std::string&);

    ObjectId get_new_blank_node();

    template<typename IndexOptions, typename OptionHandlerFunc>
    void parse_index_options(
        SparqlUpdateParser::CreateIndexOptionsContext* ctx,
        IndexOptions& index_opts,
        OptionHandlerFunc option_handler_func
    );

public:
    UpdateVisitor();

    // The final result will be stored here to be moved out
    std::unique_ptr<OpUpdate> op_update;

    virtual std::any visitQuery(SparqlUpdateParser::QueryContext*) override;
    virtual std::any visitPrologue(SparqlUpdateParser::PrologueContext*) override;
    virtual std::any visitBaseDecl(SparqlUpdateParser::BaseDeclContext*) override;
    virtual std::any visitPrefixDecl(SparqlUpdateParser::PrefixDeclContext*) override;

    virtual std::any visitInsertData(SparqlUpdateParser::InsertDataContext*) override;
    virtual std::any visitDeleteData(SparqlUpdateParser::DeleteDataContext*) override;
    virtual std::any visitTriplesTemplate(SparqlUpdateParser::TriplesTemplateContext*) override;

    virtual std::any visitTriplesSameSubject(SparqlUpdateParser::TriplesSameSubjectContext*) override;
    virtual std::any visitPropertyListNotEmpty(SparqlUpdateParser::PropertyListNotEmptyContext*) override;
    virtual std::any visitPropertyListPathNotEmpty(SparqlUpdateParser::PropertyListPathNotEmptyContext*) override;
    virtual std::any visitObject(SparqlUpdateParser::ObjectContext*) override;
    virtual std::any visitObjectPath(SparqlUpdateParser::ObjectPathContext*) override;
    virtual std::any visitCollection(SparqlUpdateParser::CollectionContext*) override;
    virtual std::any visitCollectionPath(SparqlUpdateParser::CollectionPathContext*) override;

    virtual std::any visitVerb(SparqlUpdateParser::VerbContext*) override;

    // graphTerm
    virtual std::any visitIri(SparqlUpdateParser::IriContext*) override;
    virtual std::any visitRdfLiteral(SparqlUpdateParser::RdfLiteralContext*) override;
    virtual std::any visitNumericLiteralUnsigned(SparqlUpdateParser::NumericLiteralUnsignedContext*) override;
    virtual std::any visitNumericLiteralPositive(SparqlUpdateParser::NumericLiteralPositiveContext*) override;
    virtual std::any visitNumericLiteralNegative(SparqlUpdateParser::NumericLiteralNegativeContext*) override;
    virtual std::any visitBooleanLiteral(SparqlUpdateParser::BooleanLiteralContext*) override;
    virtual std::any visitBlankNode(SparqlUpdateParser::BlankNodeContext*) override;
    virtual std::any visitNil(SparqlUpdateParser::NilContext*) override;

    std::any visitCreateIndexQuery(SparqlUpdateParser::CreateIndexQueryContext*) override;
};
}
